
filter {
  if [service][name] == "veeam" and [message] and (
       [event][dataset] == "veeam.syslog" or [event][dataset] == "veeam.failures"
     ) {

    # 1) Syslog-Header (optional)
    grok {
      match => {
        "message" => [
          "^<%{NONNEGINT:syslog.pri}>1 %{TIMESTAMP_ISO8601:syslog.ts} %{HOSTNAME:syslog.host} %{DATA:syslog.app} %{DATA:syslog.proc} %{DATA:syslog.msgid} \[%{DATA:syslog.structured_data}\] %{GREEDYDATA:syslog.msg}$"
        ]
      }
      tag_on_failure => ["grok_syslog_fail"]
    }

    # 2) Payload normalisieren & KVs parsen
    mutate {
      gsub => [ "[syslog.msg]", "^\[|\]$", "" ]
    }

    kv {
      source              => "[syslog.msg]"
      target              => "kv"
      field_split_pattern => "\s+"
      value_split         => "="
      trim_key            => "\"\[\]"
      trim_value          => "\""
#      include_brackets    => false
#      parse_value         => false
    }

    # gewünschte Felder übernehmen
    mutate {
      rename => {
        "[kv][JobName]"       => "[veeam][job][name]"
        "[kv][VbrVersion]"    => "[veeam][VbrVersion]"
        "[kv][Description]"   => "[veeam][Description]"
        "[kv][TransferredGb]" => "[veeam][TransferredGb]"
        "[kv][StorageSize]"   => "[veeam][StorageSize]"
        "[kv][VmName]"        => "[veeam][VmName]"
      }
      convert => {
        "[veeam][TransferredGb]" => "float"
        "[veeam][StorageSize]"   => "integer"
      }
    }

    # Bytes -> GB
    if [veeam][StorageSize] {
      ruby {
        code => '
          b = event.get("[veeam][StorageSize]").to_i
          gb = (b / 1024.0 / 1024.0 / 1024.0).round(2)
          event.set("[veeam][StorageSizeGB]", gb)
        '
      }
    }

    # 3) Outcome bestimmen
    mutate { lowercase => ["[kv][JobResult]", "[kv][WillBeRetried]"] }
    if [kv][JobResult] in ["0","success"] {
      mutate { replace => { "[event][outcome]" => "success" } }
    } else if [kv][JobResult] == "warning" {
      mutate { replace => { "[event][outcome]" => "warning" } }
    } else if [kv][JobResult] {
      mutate { replace => { "[event][outcome]" => "failure" } }
    }

    # 3a) event.type aus Outcome
    if [event][outcome] == "failure" {
      mutate { replace => { "[event][type]" => "error" } }
    } else {
      mutate { replace => { "[event][type]" => "info" } }
    }

    # 4) ECS-Kategorisierung & Dataset vereinheitlichen
    mutate {
      add_field => {
        "[event][category]"   => "backup"
        "[observer][vendor]"  => "Veeam"
        "[observer][product]" => "Backup & Replication"
      }
      replace => { "[event][dataset]" => "veeam.syslog" }
      update  => { "[service][type]"  => "veeam" }
    }

    # 4a) Zeitstempel übernehmen
    if [syslog][ts] {
      date { match => ["[syslog][ts]", "ISO8601"] target => "@timestamp" }
      date { match => ["[syslog][ts]", "ISO8601"] target => "[event][created]" }
    }

    # 5) Doppelte Kategorien vermeiden
    ruby {
      code => '
        cats = event.get("event.category")
        if cats.is_a?(Array)
          event.set("event.category", cats.uniq)
        end
      '
    }

    # 6) host.ip entfernen – source.ip behalten
    mutate { remove_field => ["[host][ip]"] }

    # 7) Aufräumen
    mutate {
      remove_field => [
        "message",
        "[syslog.msg]",
        "syslog",
        "kv",
        "JobResult","WillBeRetried",
        "Description","VbrHostName","VbrVersion","Version",
        "categoryId","instanceId","JobID","JobSessionID","Platform","SourceType"
      ]
    }

    # 8) Zielalias setzen
    mutate {
      add_field => { "[@metadata][es_alias]" => "logs-%{[labels][kunde]}-veeam-syslog-write" }
    }
  }
}
