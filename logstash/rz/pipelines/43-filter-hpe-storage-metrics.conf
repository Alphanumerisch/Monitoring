filter {
  # Greife nur HPE-Storage-Metriken ab (vom Edge-Input)
  if ([service][name] == "hpe-storage" or [event][dataset] == "hpe-storage.metrics" or [service][type] == "hpe.smartarray") {

    # Ankunftszeit sichern (nur wenn noch nicht vorhanden)
    ruby {
      code => '
        if !event.get("[event][ingested]")
          event.set("[event][ingested]", event.get("@timestamp"))
        end
      '
    }

    # Messzeit aus dem JSON-Feld @timestamp als echten Timestamp setzen - nur wenn noch String
    if [@timestamp] and ([@timestamp] =~ "^\d{4}-") {
      date {
        match  => ["@timestamp", "ISO8601"]
        target => "@timestamp"
        tag_on_failure => ["_dateparsefailure_hpe1"]
      }
    }

    # @timestamp aus JSON (ISO8601) als echten Timestamp verwenden
    if [@timestamp] and ([@timestamp] =~ "^\d{4}-") {
      date {
        match  => ["@timestamp", "ISO8601"]
        # target weglassen = setzt das Event-@timestamp
        tag_on_failure => ["_dateparsefailure_hpe2"]
      }
    }

    # Defaults/Anreicherung
    if ![service][type] {
      mutate { add_field => { "[service][type]" => "hpe.smartarray" } }
    }
    if ![event][category] {
      mutate { add_field => { "[event][category]" => "storage" } }
    }

    # Dokument-Typ bestimmen und ECS event.type setzen
    if [hpe][pd] {
      mutate {
        add_field => { "[event][type]" => "physical_drive" }
        add_tag   => [ "hpe-storage", "hpe:pd" ]
      }
      # Numerik-Konvertierung (falls vom Edge mal als String reinkommt)
      mutate {
        convert => {
          "[hpe][pd][bay_number]"                => "integer"
          "[hpe][pd][size_bytes]"                => "integer"
          "[hpe][pd][temperature_c]"            => "integer"
          "[hpe][pd][temperature_max_c]"        => "integer"
          "[hpe][pd][media_error_count]"        => "integer"
          "[hpe][pd][recoverable_error_count]"  => "integer"
          "[hpe][pd][logical_block_size_bytes]" => "integer"
          "[hpe][pd][physical_block_size_bytes]" => "integer"
          "[hpe][pd][phy][count]"               => "integer"
        }
      }

    } else if [hpe][ld] {
      mutate {
        add_field => { "[event][type]" => "logical_drive" }
        add_tag   => [ "hpe-storage", "hpe:ld" ]
      }
      mutate {
        convert => {
          "[hpe][ld][number]"                 => "integer"
          "[hpe][ld][size_bytes]"             => "integer"
          "[hpe][ld][heads]"                  => "integer"
          "[hpe][ld][sectors_per_track]"      => "integer"
          "[hpe][ld][cylinders]"              => "integer"
          "[hpe][ld][stripe_size_bytes]"      => "integer"
          "[hpe][ld][full_stripe_size_bytes]" => "integer"
        }
      }

    } else if [hpe][ctrl] {
      mutate {
        add_field => { "[event][type]" => "controller" }
        add_tag   => [ "hpe-storage", "hpe:ctrl" ]
      }
      mutate {
        convert => {
          "[hpe][ctrl][temperature_c]"             => "integer"
          "[hpe][ctrl][cache_module_temperature_c]" => "integer"
          "[hpe][ctrl][ports][count]"              => "integer"
          "[hpe][ctrl][battery][count]"            => "integer"
          "[hpe][ctrl][total_cache_size_gb]"       => "float"
          "[hpe][ctrl][total_cache_memory_available_gb]" => "float"
        }
      }
    }

    # Write-Alias fÃ¼r den ES-Output vorbereiten
    mutate {
             add_field => { "[@metadata][es_alias]" => "status-%{[labels][kunde]}-hpe-storage-write" } 
            }
    
  }
}
