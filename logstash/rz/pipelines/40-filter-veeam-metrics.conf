filter {
  if [service][name] == "veeam" and [event][dataset] == "veeam.jobs" {

    # 1) Zeiten setzen: event.start / event.end aus Script‑Feldern
    if [lastRun][start] {
      date { match => ["[lastRun][start]", "ISO8601"] target => "[event][start]" }
    }
    if [lastRun][end] {
      date { match => ["[lastRun][end]",   "ISO8601"] target => "[event][end]" }
      # @timestamp = fachliche Endzeit
    }

    # 2) Dauer berechnen (ms), falls start & end vorhanden
    ruby {
      code => '
        begin
          s = event.get("[event][start]"); e = event.get("[event][end]")
          if s && e
            dur_ms = (LogStash::Timestamp.coerce(e).time - LogStash::Timestamp.coerce(s).time) * 1000
            event.set("[event][duration]", dur_ms.to_i)
          end
        rescue => ex
          event.tag("calc_duration_error")
        end
      '
    }

    # 3) Outcome bestimmen
    mutate { lowercase => ["status", "lastResultRaw"] }
    if [status] in ["success","ok"] or [lastResultRaw] == "success" {
      mutate { replace => { "[event][outcome]" => "success" } }
    } else if [status] == "warning" or [lastResultRaw] == "warning" {
      mutate { replace => { "[event][outcome]" => "warning" } }
    } else {
      mutate { replace => { "[event][outcome]" => "failure" } }
    }


    # ECS-Kategorisierung (global konsistent)
    mutate {
      add_field => {
        "[event][category]" => "backup"
        "[event][kind]"     => "event"
      }
    }

    # event.type aus Outcome ableiten (info|error)
    if [event][outcome] == "failure" {
      mutate { replace => { "[event][type]" => "error" } }
    } else {
      mutate { replace => { "[event][type]" => "info" } }
    }

    # Defaults für Vendor/Product/Service-Typ
    mutate {
      update => { "[service][type]" => "veeam" }
      add_field => {
        "[observer][vendor]"  => "Veeam"
        "[observer][product]" => "Backup & Replication"
      }
    }


    # 4) Job‑Felder in Namespace veeam.*
    if [jobName] { mutate { rename => { "[jobName]" => "[veeam][job][name]" } } }

   # observer.hostname nur setzen, wenn noch nicht vorhanden
#   if ![observer][hostname] and [host][name] {
#     mutate { add_field => { "[observer][hostname]" => "%{[host][name]}" } }
#   }

    # 5) nextRun mappen
    if [nextRun] { date { match => ["[nextRun]", "ISO8601"] target => "[veeam][next_run]" } }

    # 6) Ingest‑Latenz (optional)
    ruby {
      code => '
        begin
          e = event.get("[event][end]"); i = event.get("[event][ingested]")
          if e && i
            lat = (LogStash::Timestamp.coerce(i).time - LogStash::Timestamp.coerce(e).time) * 1000
            event.set("[veeam][ingest_latency_ms]", lat.to_i)
          end
        rescue; end
      '
    }

    # 7) Rohfelder entfernen (keine Duplikate im Index)
    mutate {
      remove_field => ["jobName", "status", "lastRun", "nextRun", "lastResultRaw", "scheduleEnabled"]
    }

    # 8) Zielalias für ES setzen (Write‑Alias)
    mutate {
      add_field => { "[@metadata][es_alias]" => "metrics-%{[labels][kunde]}-veeam-jobs-write" }
    }
  }
}
