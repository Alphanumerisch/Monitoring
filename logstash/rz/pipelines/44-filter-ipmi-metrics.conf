filter {
  # Nur IPMI-Events anfassen:
  if [service][name] == "ipmi-metrics"
     or [service][type] == "ipmi"
     or "ipmi.temp" in [event][dataset]
     or "ipmi.fan" in [event][dataset]
     or "ipmi.power" in [event][dataset] {

    # @timestamp (ISO8601) sauber setzen - nur wenn noch String
    if [@timestamp] and ([@timestamp] =~ "^\d{4}-") {
      date {
        match   => ["@timestamp", "ISO8601"]
        target  => "@timestamp"
        timezone => "UTC"
        tag_on_failure => ["_dateparsefailure_ipmi"]
      }
    }

    # ECS-Defaults absichern (nur wenn noch nicht vorhanden)
    if ![service][type] {
      mutate { add_field => { "[service][type]" => "ipmi" } }
    }
    if ![event][kind] {
      mutate { add_field => { "[event][kind]" => "metric" } }
    }
    if ![event][category] { mutate { add_field => { "[event][category]" => "hardware" } } }
    if ![event][type]     { mutate { add_field => { "[event][type]"     => "info"     } } }

    # dataset vereinheitlichen basierend auf Metriken-Typ
    if [metrics][temperature] {
      mutate { replace => { "[event][dataset]" => "ipmi.temp" } }
    } else if [metrics][fan] {
      mutate { replace => { "[event][dataset]" => "ipmi.fan" } }
    } else if [metrics][power] {
      mutate { replace => { "[event][dataset]" => "ipmi.power" } }
    }

    # Observer-Informationen standardisieren (nur wenn noch nicht vorhanden)
    if ![observer][vendor] {
      mutate { add_field => { "[observer][vendor]" => "Generic" } }
    }
    if ![observer][product] {
      mutate { add_field => { "[observer][product]" => "IPMI" } }
    }

    # Numerische Werte sicherstellen (falls vom Edge als String kommen)
    if [metrics][temperature][celsius] {
      mutate { convert => { "[metrics][temperature][celsius]" => "float" } }
    }
    if [metrics][fan][rpm] {
      mutate { convert => { "[metrics][fan][rpm]" => "float" } }
    }
    if [metrics][power][watts] {
      mutate { convert => { "[metrics][power][watts]" => "float" } }
    }

    # IPMI-spezifische Felder validieren und bereinigen
    if [ipmi][sensor] {
      # Sensor-Name bereinigen (führende/nachfolgende Leerzeichen entfernen)
      if [ipmi][sensor][name] {
        mutate { 
          gsub => [ "[ipmi][sensor][name]", "^\\s+|\\s+$", "" ]
        }
      }
      
      # Status-Werte normalisieren
      if [ipmi][sensor][status] {
        mutate { 
          lowercase => [ "[ipmi][sensor][status]" ]
          gsub => [ "[ipmi][sensor][status]", "^\\s+|\\s+$", "" ]
        }
      }
      
      # Unit-Werte normalisieren
      if [ipmi][sensor][unit] {
        mutate { 
          lowercase => [ "[ipmi][sensor][unit]" ]
          gsub => [ "[ipmi][sensor][unit]", "^\\s+|\\s+$", "" ]
        }
      }
    }

    # Event-Outcome basierend auf Sensor-Status setzen
    if [ipmi][sensor][status] {
      if [ipmi][sensor][status] in ["ok", "good", "normal"] {
        mutate { replace => { "[event][outcome]" => "success" } }
      } else if [ipmi][sensor][status] in ["warning", "caution"] {
        mutate { replace => { "[event][outcome]" => "warning" } }
      } else if [ipmi][sensor][status] in ["critical", "fatal", "error", "failed"] {
        mutate { replace => { "[event][outcome]" => "failure" } }
        mutate { replace => { "[event][type]" => "error" } }
      } else {
        mutate { replace => { "[event][outcome]" => "unknown" } }
      }
    }

    # Rohfelder entfernen (keine Duplikate im Index)
    mutate {
      remove_field => [
        "message",
        "syslog",
        "kv"
      ]
    }

    # Zielalias für ES setzen (Write-Alias)
    mutate {
      add_field => { "[@metadata][es_alias]" => "metrics-%{[labels][kunde]}-ipmi-write" }
    }
  }
}
